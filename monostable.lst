                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ISO C Compiler 
                                      3 ; Version 4.4.0 #14620 (MINGW32)
                                      4 ;--------------------------------------------------------
                                      5 	.module monostable
                                      6 	.optsdcc -mmcs51 --model-small
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _main
                                     12 	.globl _Timer1_ISR
                                     13 	.globl _int_ISR
                                     14 	.globl _delay_ms
                                     15 	.globl _Timer0_ISR
                                     16 	.globl _int0Init
                                     17 	.globl _timer1Init
                                     18 	.globl _timer0Init
                                     19 	.globl _I2C_DataRead
                                     20 	.globl _I2C_DataWrite
                                     21 	.globl _acknowledge
                                     22 	.globl _I2C_Stop
                                     23 	.globl _I2C_Start
                                     24 	.globl _delay
                                     25 	.globl _displayDigit
                                     26 	.globl _TF2
                                     27 	.globl _EXF2
                                     28 	.globl _RCLK
                                     29 	.globl _TCLK
                                     30 	.globl _EXEN2
                                     31 	.globl _TR2
                                     32 	.globl _C_T2
                                     33 	.globl _CP_RL2
                                     34 	.globl _T2CON_7
                                     35 	.globl _T2CON_6
                                     36 	.globl _T2CON_5
                                     37 	.globl _T2CON_4
                                     38 	.globl _T2CON_3
                                     39 	.globl _T2CON_2
                                     40 	.globl _T2CON_1
                                     41 	.globl _T2CON_0
                                     42 	.globl _PT2
                                     43 	.globl _ET2
                                     44 	.globl _CY
                                     45 	.globl _AC
                                     46 	.globl _F0
                                     47 	.globl _RS1
                                     48 	.globl _RS0
                                     49 	.globl _OV
                                     50 	.globl _F1
                                     51 	.globl _P
                                     52 	.globl _PS
                                     53 	.globl _PT1
                                     54 	.globl _PX1
                                     55 	.globl _PT0
                                     56 	.globl _PX0
                                     57 	.globl _RD
                                     58 	.globl _WR
                                     59 	.globl _T1
                                     60 	.globl _T0
                                     61 	.globl _INT1
                                     62 	.globl _INT0
                                     63 	.globl _TXD
                                     64 	.globl _RXD
                                     65 	.globl _P3_7
                                     66 	.globl _P3_6
                                     67 	.globl _P3_5
                                     68 	.globl _P3_4
                                     69 	.globl _P3_3
                                     70 	.globl _P3_2
                                     71 	.globl _P3_1
                                     72 	.globl _P3_0
                                     73 	.globl _EA
                                     74 	.globl _ES
                                     75 	.globl _ET1
                                     76 	.globl _EX1
                                     77 	.globl _ET0
                                     78 	.globl _EX0
                                     79 	.globl _P2_7
                                     80 	.globl _P2_6
                                     81 	.globl _P2_5
                                     82 	.globl _P2_4
                                     83 	.globl _P2_3
                                     84 	.globl _P2_2
                                     85 	.globl _P2_1
                                     86 	.globl _P2_0
                                     87 	.globl _SM0
                                     88 	.globl _SM1
                                     89 	.globl _SM2
                                     90 	.globl _REN
                                     91 	.globl _TB8
                                     92 	.globl _RB8
                                     93 	.globl _TI
                                     94 	.globl _RI
                                     95 	.globl _P1_7
                                     96 	.globl _P1_6
                                     97 	.globl _P1_5
                                     98 	.globl _P1_4
                                     99 	.globl _P1_3
                                    100 	.globl _P1_2
                                    101 	.globl _P1_1
                                    102 	.globl _P1_0
                                    103 	.globl _TF1
                                    104 	.globl _TR1
                                    105 	.globl _TF0
                                    106 	.globl _TR0
                                    107 	.globl _IE1
                                    108 	.globl _IT1
                                    109 	.globl _IE0
                                    110 	.globl _IT0
                                    111 	.globl _P0_7
                                    112 	.globl _P0_6
                                    113 	.globl _P0_5
                                    114 	.globl _P0_4
                                    115 	.globl _P0_3
                                    116 	.globl _P0_2
                                    117 	.globl _P0_1
                                    118 	.globl _P0_0
                                    119 	.globl _TH2
                                    120 	.globl _TL2
                                    121 	.globl _RCAP2H
                                    122 	.globl _RCAP2L
                                    123 	.globl _T2CON
                                    124 	.globl _B
                                    125 	.globl _ACC
                                    126 	.globl _PSW
                                    127 	.globl _IP
                                    128 	.globl _P3
                                    129 	.globl _IE
                                    130 	.globl _P2
                                    131 	.globl _SBUF
                                    132 	.globl _SCON
                                    133 	.globl _P1
                                    134 	.globl _TH1
                                    135 	.globl _TH0
                                    136 	.globl _TL1
                                    137 	.globl _TL0
                                    138 	.globl _TMOD
                                    139 	.globl _TCON
                                    140 	.globl _PCON
                                    141 	.globl _DPH
                                    142 	.globl _DPL
                                    143 	.globl _SP
                                    144 	.globl _P0
                                    145 	.globl _interrupt_counter
                                    146 	.globl _acceleration
                                    147 	.globl _longPressTime
                                    148 	.globl _dispalay_data
                                    149 	.globl _currentDigit
                                    150 	.globl _delayTime
                                    151 	.globl _stat
                                    152 	.globl _buttonStat
                                    153 	.globl _lastButtonStat
                                    154 	.globl _displayData
                                    155 	.globl _saving
                                    156 ;--------------------------------------------------------
                                    157 ; special function registers
                                    158 ;--------------------------------------------------------
                                    159 	.area RSEG    (ABS,DATA)
      000000                        160 	.org 0x0000
                           000080   161 _P0	=	0x0080
                           000081   162 _SP	=	0x0081
                           000082   163 _DPL	=	0x0082
                           000083   164 _DPH	=	0x0083
                           000087   165 _PCON	=	0x0087
                           000088   166 _TCON	=	0x0088
                           000089   167 _TMOD	=	0x0089
                           00008A   168 _TL0	=	0x008a
                           00008B   169 _TL1	=	0x008b
                           00008C   170 _TH0	=	0x008c
                           00008D   171 _TH1	=	0x008d
                           000090   172 _P1	=	0x0090
                           000098   173 _SCON	=	0x0098
                           000099   174 _SBUF	=	0x0099
                           0000A0   175 _P2	=	0x00a0
                           0000A8   176 _IE	=	0x00a8
                           0000B0   177 _P3	=	0x00b0
                           0000B8   178 _IP	=	0x00b8
                           0000D0   179 _PSW	=	0x00d0
                           0000E0   180 _ACC	=	0x00e0
                           0000F0   181 _B	=	0x00f0
                           0000C8   182 _T2CON	=	0x00c8
                           0000CA   183 _RCAP2L	=	0x00ca
                           0000CB   184 _RCAP2H	=	0x00cb
                           0000CC   185 _TL2	=	0x00cc
                           0000CD   186 _TH2	=	0x00cd
                                    187 ;--------------------------------------------------------
                                    188 ; special function bits
                                    189 ;--------------------------------------------------------
                                    190 	.area RSEG    (ABS,DATA)
      000000                        191 	.org 0x0000
                           000080   192 _P0_0	=	0x0080
                           000081   193 _P0_1	=	0x0081
                           000082   194 _P0_2	=	0x0082
                           000083   195 _P0_3	=	0x0083
                           000084   196 _P0_4	=	0x0084
                           000085   197 _P0_5	=	0x0085
                           000086   198 _P0_6	=	0x0086
                           000087   199 _P0_7	=	0x0087
                           000088   200 _IT0	=	0x0088
                           000089   201 _IE0	=	0x0089
                           00008A   202 _IT1	=	0x008a
                           00008B   203 _IE1	=	0x008b
                           00008C   204 _TR0	=	0x008c
                           00008D   205 _TF0	=	0x008d
                           00008E   206 _TR1	=	0x008e
                           00008F   207 _TF1	=	0x008f
                           000090   208 _P1_0	=	0x0090
                           000091   209 _P1_1	=	0x0091
                           000092   210 _P1_2	=	0x0092
                           000093   211 _P1_3	=	0x0093
                           000094   212 _P1_4	=	0x0094
                           000095   213 _P1_5	=	0x0095
                           000096   214 _P1_6	=	0x0096
                           000097   215 _P1_7	=	0x0097
                           000098   216 _RI	=	0x0098
                           000099   217 _TI	=	0x0099
                           00009A   218 _RB8	=	0x009a
                           00009B   219 _TB8	=	0x009b
                           00009C   220 _REN	=	0x009c
                           00009D   221 _SM2	=	0x009d
                           00009E   222 _SM1	=	0x009e
                           00009F   223 _SM0	=	0x009f
                           0000A0   224 _P2_0	=	0x00a0
                           0000A1   225 _P2_1	=	0x00a1
                           0000A2   226 _P2_2	=	0x00a2
                           0000A3   227 _P2_3	=	0x00a3
                           0000A4   228 _P2_4	=	0x00a4
                           0000A5   229 _P2_5	=	0x00a5
                           0000A6   230 _P2_6	=	0x00a6
                           0000A7   231 _P2_7	=	0x00a7
                           0000A8   232 _EX0	=	0x00a8
                           0000A9   233 _ET0	=	0x00a9
                           0000AA   234 _EX1	=	0x00aa
                           0000AB   235 _ET1	=	0x00ab
                           0000AC   236 _ES	=	0x00ac
                           0000AF   237 _EA	=	0x00af
                           0000B0   238 _P3_0	=	0x00b0
                           0000B1   239 _P3_1	=	0x00b1
                           0000B2   240 _P3_2	=	0x00b2
                           0000B3   241 _P3_3	=	0x00b3
                           0000B4   242 _P3_4	=	0x00b4
                           0000B5   243 _P3_5	=	0x00b5
                           0000B6   244 _P3_6	=	0x00b6
                           0000B7   245 _P3_7	=	0x00b7
                           0000B0   246 _RXD	=	0x00b0
                           0000B1   247 _TXD	=	0x00b1
                           0000B2   248 _INT0	=	0x00b2
                           0000B3   249 _INT1	=	0x00b3
                           0000B4   250 _T0	=	0x00b4
                           0000B5   251 _T1	=	0x00b5
                           0000B6   252 _WR	=	0x00b6
                           0000B7   253 _RD	=	0x00b7
                           0000B8   254 _PX0	=	0x00b8
                           0000B9   255 _PT0	=	0x00b9
                           0000BA   256 _PX1	=	0x00ba
                           0000BB   257 _PT1	=	0x00bb
                           0000BC   258 _PS	=	0x00bc
                           0000D0   259 _P	=	0x00d0
                           0000D1   260 _F1	=	0x00d1
                           0000D2   261 _OV	=	0x00d2
                           0000D3   262 _RS0	=	0x00d3
                           0000D4   263 _RS1	=	0x00d4
                           0000D5   264 _F0	=	0x00d5
                           0000D6   265 _AC	=	0x00d6
                           0000D7   266 _CY	=	0x00d7
                           0000AD   267 _ET2	=	0x00ad
                           0000BD   268 _PT2	=	0x00bd
                           0000C8   269 _T2CON_0	=	0x00c8
                           0000C9   270 _T2CON_1	=	0x00c9
                           0000CA   271 _T2CON_2	=	0x00ca
                           0000CB   272 _T2CON_3	=	0x00cb
                           0000CC   273 _T2CON_4	=	0x00cc
                           0000CD   274 _T2CON_5	=	0x00cd
                           0000CE   275 _T2CON_6	=	0x00ce
                           0000CF   276 _T2CON_7	=	0x00cf
                           0000C8   277 _CP_RL2	=	0x00c8
                           0000C9   278 _C_T2	=	0x00c9
                           0000CA   279 _TR2	=	0x00ca
                           0000CB   280 _EXEN2	=	0x00cb
                           0000CC   281 _TCLK	=	0x00cc
                           0000CD   282 _RCLK	=	0x00cd
                           0000CE   283 _EXF2	=	0x00ce
                           0000CF   284 _TF2	=	0x00cf
                                    285 ;--------------------------------------------------------
                                    286 ; overlayable register banks
                                    287 ;--------------------------------------------------------
                                    288 	.area REG_BANK_0	(REL,OVR,DATA)
      000000                        289 	.ds 8
                                    290 ;--------------------------------------------------------
                                    291 ; overlayable bit register bank
                                    292 ;--------------------------------------------------------
                                    293 	.area BIT_BANK	(REL,OVR,DATA)
      000000                        294 bits:
      000000                        295 	.ds 1
                           008000   296 	b0 = bits[0]
                           008100   297 	b1 = bits[1]
                           008200   298 	b2 = bits[2]
                           008300   299 	b3 = bits[3]
                           008400   300 	b4 = bits[4]
                           008500   301 	b5 = bits[5]
                           008600   302 	b6 = bits[6]
                           008700   303 	b7 = bits[7]
                                    304 ;--------------------------------------------------------
                                    305 ; internal ram data
                                    306 ;--------------------------------------------------------
                                    307 	.area DSEG    (DATA)
      000000                        308 _displayData::
      000000                        309 	.ds 11
      00000B                        310 _lastButtonStat::
      00000B                        311 	.ds 1
      00000C                        312 _buttonStat::
      00000C                        313 	.ds 1
      00000D                        314 _stat::
      00000D                        315 	.ds 1
      00000E                        316 _delayTime::
      00000E                        317 	.ds 2
      000010                        318 _currentDigit::
      000010                        319 	.ds 1
      000011                        320 _dispalay_data::
      000011                        321 	.ds 4
      000015                        322 _longPressTime::
      000015                        323 	.ds 2
      000017                        324 _acceleration::
      000017                        325 	.ds 2
      000019                        326 _interrupt_counter::
      000019                        327 	.ds 4
                                    328 ;--------------------------------------------------------
                                    329 ; overlayable items in internal ram
                                    330 ;--------------------------------------------------------
                                    331 	.area	OSEG    (OVR,DATA)
                                    332 	.area	OSEG    (OVR,DATA)
                                    333 	.area	OSEG    (OVR,DATA)
                                    334 	.area	OSEG    (OVR,DATA)
                                    335 	.area	OSEG    (OVR,DATA)
                                    336 ;--------------------------------------------------------
                                    337 ; Stack segment in internal ram
                                    338 ;--------------------------------------------------------
                                    339 	.area SSEG
      000000                        340 __start__stack:
      000000                        341 	.ds	1
                                    342 
                                    343 ;--------------------------------------------------------
                                    344 ; indirectly addressable internal ram data
                                    345 ;--------------------------------------------------------
                                    346 	.area ISEG    (DATA)
                                    347 ;--------------------------------------------------------
                                    348 ; absolute internal ram data
                                    349 ;--------------------------------------------------------
                                    350 	.area IABS    (ABS,DATA)
                                    351 	.area IABS    (ABS,DATA)
                                    352 ;--------------------------------------------------------
                                    353 ; bit data
                                    354 ;--------------------------------------------------------
                                    355 	.area BSEG    (BIT)
                                    356 ;--------------------------------------------------------
                                    357 ; paged external ram data
                                    358 ;--------------------------------------------------------
                                    359 	.area PSEG    (PAG,XDATA)
                                    360 ;--------------------------------------------------------
                                    361 ; uninitialized external ram data
                                    362 ;--------------------------------------------------------
                                    363 	.area XSEG    (XDATA)
                                    364 ;--------------------------------------------------------
                                    365 ; absolute external ram data
                                    366 ;--------------------------------------------------------
                                    367 	.area XABS    (ABS,XDATA)
                                    368 ;--------------------------------------------------------
                                    369 ; initialized external ram data
                                    370 ;--------------------------------------------------------
                                    371 	.area XISEG   (XDATA)
                                    372 	.area HOME    (CODE)
                                    373 	.area GSINIT0 (CODE)
                                    374 	.area GSINIT1 (CODE)
                                    375 	.area GSINIT2 (CODE)
                                    376 	.area GSINIT3 (CODE)
                                    377 	.area GSINIT4 (CODE)
                                    378 	.area GSINIT5 (CODE)
                                    379 	.area GSINIT  (CODE)
                                    380 	.area GSFINAL (CODE)
                                    381 	.area CSEG    (CODE)
                                    382 ;--------------------------------------------------------
                                    383 ; interrupt vector
                                    384 ;--------------------------------------------------------
                                    385 	.area HOME    (CODE)
      000000                        386 __interrupt_vect:
      000000 02r00r00         [24]  387 	ljmp	__sdcc_gsinit_startup
      000003 02r02r62         [24]  388 	ljmp	_int_ISR
      000006                        389 	.ds	5
      00000B 02r00rA7         [24]  390 	ljmp	_Timer0_ISR
      00000E                        391 	.ds	5
      000013 32               [24]  392 	reti
      000014                        393 	.ds	7
      00001B 02r02rA3         [24]  394 	ljmp	_Timer1_ISR
                                    395 ;--------------------------------------------------------
                                    396 ; global & static initialisations
                                    397 ;--------------------------------------------------------
                                    398 	.area HOME    (CODE)
                                    399 	.area GSINIT  (CODE)
                                    400 	.area GSFINAL (CODE)
                                    401 	.area GSINIT  (CODE)
                                    402 	.globl __sdcc_gsinit_startup
                                    403 	.globl __sdcc_program_startup
                                    404 	.globl __start__stack
                                    405 	.globl __mcs51_genXINIT
                                    406 	.globl __mcs51_genXRAMCLEAR
                                    407 	.globl __mcs51_genRAMCLEAR
                                    408 ;	monostable.c:29: volatile unsigned char displayData[] = {
      000000 75*00 C0         [24]  409 	mov	_displayData,#0xc0
      000003 75*01 F9         [24]  410 	mov	(_displayData + 0x0001),#0xf9
      000006 75*02 A4         [24]  411 	mov	(_displayData + 0x0002),#0xa4
      000009 75*03 B0         [24]  412 	mov	(_displayData + 0x0003),#0xb0
      00000C 75*04 99         [24]  413 	mov	(_displayData + 0x0004),#0x99
      00000F 75*05 92         [24]  414 	mov	(_displayData + 0x0005),#0x92
      000012 75*06 82         [24]  415 	mov	(_displayData + 0x0006),#0x82
      000015 75*07 F8         [24]  416 	mov	(_displayData + 0x0007),#0xf8
      000018 75*08 80         [24]  417 	mov	(_displayData + 0x0008),#0x80
      00001B 75*09 90         [24]  418 	mov	(_displayData + 0x0009),#0x90
      00001E 75*0A BF         [24]  419 	mov	(_displayData + 0x000a),#0xbf
                                    420 ;	monostable.c:48: unsigned char lastButtonStat = 1;
      000021 75*0B 01         [24]  421 	mov	_lastButtonStat,#0x01
                                    422 ;	monostable.c:49: unsigned char buttonStat = 1;
      000024 75*0C 01         [24]  423 	mov	_buttonStat,#0x01
                                    424 ;	monostable.c:51: volatile unsigned char stat = 1;
      000027 75*0D 01         [24]  425 	mov	_stat,#0x01
                                    426 ;	monostable.c:52: volatile  unsigned int delayTime = 2000;
      00002A 75*0E D0         [24]  427 	mov	_delayTime,#0xd0
      00002D 75*0F 07         [24]  428 	mov	(_delayTime + 1),#0x07
                                    429 ;	monostable.c:53: volatile unsigned char currentDigit = 0;
      000030 75*10 00         [24]  430 	mov	_currentDigit,#0x00
                                    431 ;	monostable.c:54: unsigned long dispalay_data = 0;
      000033 E4               [12]  432 	clr	a
      000034 F5*11            [12]  433 	mov	_dispalay_data,a
      000036 F5*12            [12]  434 	mov	(_dispalay_data + 1),a
      000038 F5*13            [12]  435 	mov	(_dispalay_data + 2),a
      00003A F5*14            [12]  436 	mov	(_dispalay_data + 3),a
                                    437 ;	monostable.c:55: unsigned int longPressTime = 0;
      00003C F5*15            [12]  438 	mov	_longPressTime,a
      00003E F5*16            [12]  439 	mov	(_longPressTime + 1),a
                                    440 ;	monostable.c:56: unsigned int acceleration = 1;
      000040 75*17 01         [24]  441 	mov	_acceleration,#0x01
      000043 F5*18            [12]  442 	mov	(_acceleration + 1),a
                                    443 ;	monostable.c:57: unsigned long interrupt_counter = 0;
      000045 F5*19            [12]  444 	mov	_interrupt_counter,a
      000047 F5*1A            [12]  445 	mov	(_interrupt_counter + 1),a
      000049 F5*1B            [12]  446 	mov	(_interrupt_counter + 2),a
      00004B F5*1C            [12]  447 	mov	(_interrupt_counter + 3),a
                                    448 	.area GSFINAL (CODE)
      000000 02r00r1E         [24]  449 	ljmp	__sdcc_program_startup
                                    450 ;--------------------------------------------------------
                                    451 ; Home
                                    452 ;--------------------------------------------------------
                                    453 	.area HOME    (CODE)
                                    454 	.area HOME    (CODE)
      00001E                        455 __sdcc_program_startup:
      00001E 02r02rFB         [24]  456 	ljmp	_main
                                    457 ;	return from main will return to caller
                                    458 ;--------------------------------------------------------
                                    459 ; code
                                    460 ;--------------------------------------------------------
                                    461 	.area CSEG    (CODE)
                                    462 ;------------------------------------------------------------
                                    463 ;Allocation info for local variables in function 'displayDigit'
                                    464 ;------------------------------------------------------------
                                    465 ;digit                     Allocated to registers r7 
                                    466 ;------------------------------------------------------------
                                    467 ;	monostable.c:58: volatile void displayDigit(unsigned char digit) {
                                    468 ;	-----------------------------------------
                                    469 ;	 function displayDigit
                                    470 ;	-----------------------------------------
      000000                        471 _displayDigit:
                           000007   472 	ar7 = 0x07
                           000006   473 	ar6 = 0x06
                           000005   474 	ar5 = 0x05
                           000004   475 	ar4 = 0x04
                           000003   476 	ar3 = 0x03
                           000002   477 	ar2 = 0x02
                           000001   478 	ar1 = 0x01
                           000000   479 	ar0 = 0x00
                                    480 ;	monostable.c:59: P2 = displayData[digit];
      000000 E5 82            [12]  481 	mov	a,dpl
      000002 24r00            [12]  482 	add	a, #_displayData
      000004 F9               [12]  483 	mov	r1,a
      000005 87 A0            [24]  484 	mov	_P2,@r1
                                    485 ;	monostable.c:60: }
      000007 22               [24]  486 	ret
                                    487 ;------------------------------------------------------------
                                    488 ;Allocation info for local variables in function 'delay'
                                    489 ;------------------------------------------------------------
                                    490 ;count                     Allocated to registers 
                                    491 ;------------------------------------------------------------
                                    492 ;	monostable.c:63: void delay(unsigned int count) {
                                    493 ;	-----------------------------------------
                                    494 ;	 function delay
                                    495 ;	-----------------------------------------
      000008                        496 _delay:
      000008 AE 82            [24]  497 	mov	r6, dpl
      00000A AF 83            [24]  498 	mov	r7, dph
                                    499 ;	monostable.c:64: while (count--);
      00000C                        500 00101$:
      00000C 8E 04            [24]  501 	mov	ar4,r6
      00000E 8F 05            [24]  502 	mov	ar5,r7
      000010 1E               [12]  503 	dec	r6
      000011 BE FF 01         [24]  504 	cjne	r6,#0xff,00113$
      000014 1F               [12]  505 	dec	r7
      000015                        506 00113$:
      000015 EC               [12]  507 	mov	a,r4
      000016 4D               [12]  508 	orl	a,r5
      000017 70 F3            [24]  509 	jnz	00101$
                                    510 ;	monostable.c:65: }
      000019 22               [24]  511 	ret
                                    512 ;------------------------------------------------------------
                                    513 ;Allocation info for local variables in function 'I2C_Start'
                                    514 ;------------------------------------------------------------
                                    515 ;	monostable.c:67: void I2C_Start(void) {
                                    516 ;	-----------------------------------------
                                    517 ;	 function I2C_Start
                                    518 ;	-----------------------------------------
      00001A                        519 _I2C_Start:
                                    520 ;	monostable.c:68: SDA = 1;
                                    521 ;	assignBit
      00001A D2 B7            [12]  522 	setb	_P3_7
                                    523 ;	monostable.c:69: nop;
      00001C 00               [12]  524 	nop
                                    525 ;	monostable.c:70: SCL = 1;
                                    526 ;	assignBit
      00001D D2 B6            [12]  527 	setb	_P3_6
                                    528 ;	monostable.c:71: nop;
      00001F 00               [12]  529 	nop
                                    530 ;	monostable.c:72: SDA = 0;
                                    531 ;	assignBit
      000020 C2 B7            [12]  532 	clr	_P3_7
                                    533 ;	monostable.c:73: nop;
      000022 00               [12]  534 	nop
                                    535 ;	monostable.c:74: SCL = 0;
                                    536 ;	assignBit
      000023 C2 B6            [12]  537 	clr	_P3_6
                                    538 ;	monostable.c:75: }
      000025 22               [24]  539 	ret
                                    540 ;------------------------------------------------------------
                                    541 ;Allocation info for local variables in function 'I2C_Stop'
                                    542 ;------------------------------------------------------------
                                    543 ;	monostable.c:77: void I2C_Stop(void) {
                                    544 ;	-----------------------------------------
                                    545 ;	 function I2C_Stop
                                    546 ;	-----------------------------------------
      000026                        547 _I2C_Stop:
                                    548 ;	monostable.c:78: SDA = 0;
                                    549 ;	assignBit
      000026 C2 B7            [12]  550 	clr	_P3_7
                                    551 ;	monostable.c:79: nop;
      000028 00               [12]  552 	nop
                                    553 ;	monostable.c:80: SCL = 1;
                                    554 ;	assignBit
      000029 D2 B6            [12]  555 	setb	_P3_6
                                    556 ;	monostable.c:81: nop;
      00002B 00               [12]  557 	nop
                                    558 ;	monostable.c:82: SDA = 1;
                                    559 ;	assignBit
      00002C D2 B7            [12]  560 	setb	_P3_7
                                    561 ;	monostable.c:83: nop;
      00002E 00               [12]  562 	nop
                                    563 ;	monostable.c:84: }
      00002F 22               [24]  564 	ret
                                    565 ;------------------------------------------------------------
                                    566 ;Allocation info for local variables in function 'acknowledge'
                                    567 ;------------------------------------------------------------
                                    568 ;	monostable.c:85: void acknowledge(void){
                                    569 ;	-----------------------------------------
                                    570 ;	 function acknowledge
                                    571 ;	-----------------------------------------
      000030                        572 _acknowledge:
                                    573 ;	monostable.c:86: SCL = 1;
                                    574 ;	assignBit
      000030 D2 B6            [12]  575 	setb	_P3_6
                                    576 ;	monostable.c:87: nop;
      000032 00               [12]  577 	nop
                                    578 ;	monostable.c:88: SCL = 0;
                                    579 ;	assignBit
      000033 C2 B6            [12]  580 	clr	_P3_6
                                    581 ;	monostable.c:89: }
      000035 22               [24]  582 	ret
                                    583 ;------------------------------------------------------------
                                    584 ;Allocation info for local variables in function 'I2C_DataWrite'
                                    585 ;------------------------------------------------------------
                                    586 ;Data                      Allocated to registers r7 
                                    587 ;i                         Allocated to registers r6 
                                    588 ;------------------------------------------------------------
                                    589 ;	monostable.c:91: void I2C_DataWrite(unsigned char Data)//0xA0 1010 0000--> 0100 0000
                                    590 ;	-----------------------------------------
                                    591 ;	 function I2C_DataWrite
                                    592 ;	-----------------------------------------
      000036                        593 _I2C_DataWrite:
      000036 AF 82            [24]  594 	mov	r7, dpl
                                    595 ;	monostable.c:95: for(i=0;i<8;i++)
      000038 7E 00            [12]  596 	mov	r6,#0x00
      00003A                        597 00105$:
                                    598 ;	monostable.c:97: SDA= (Data & 0x80)?1:0;
      00003A 8F 05            [24]  599 	mov	ar5,r7
      00003C 53 05 80         [24]  600 	anl	ar5,#0x80
                                    601 ;	assignBit
      00003F ED               [12]  602 	mov	a,r5
      000040 24 FF            [12]  603 	add	a,#0xff
      000042 92 B7            [24]  604 	mov	_P3_7,c
                                    605 ;	monostable.c:98: Data=Data<<1;
      000044 8F 05            [24]  606 	mov	ar5,r7
      000046 ED               [12]  607 	mov	a,r5
      000047 2D               [12]  608 	add	a,r5
      000048 FF               [12]  609 	mov	r7,a
                                    610 ;	monostable.c:99: nop;
      000049 00               [12]  611 	nop
                                    612 ;	monostable.c:100: SCL=1;
                                    613 ;	assignBit
      00004A D2 B6            [12]  614 	setb	_P3_6
                                    615 ;	monostable.c:101: nop;
      00004C 00               [12]  616 	nop
                                    617 ;	monostable.c:102: SCL=0;
                                    618 ;	assignBit
      00004D C2 B6            [12]  619 	clr	_P3_6
                                    620 ;	monostable.c:103: nop;
      00004F 00               [12]  621 	nop
                                    622 ;	monostable.c:95: for(i=0;i<8;i++)
      000050 0E               [12]  623 	inc	r6
      000051 BE 08 00         [24]  624 	cjne	r6,#0x08,00134$
      000054                        625 00134$:
      000054 40 E4            [24]  626 	jc	00105$
                                    627 ;	monostable.c:105: SDA=1;
                                    628 ;	assignBit
      000056 D2 B7            [12]  629 	setb	_P3_7
                                    630 ;	monostable.c:106: SCL=1;
                                    631 ;	assignBit
      000058 D2 B6            [12]  632 	setb	_P3_6
                                    633 ;	monostable.c:107: nop;
      00005A 00               [12]  634 	nop
                                    635 ;	monostable.c:108: while(SDA==1); //waiting until SDA=0 this should be set by the slave 
      00005B                        636 00102$:
      00005B 20 B7 FD         [24]  637 	jb	_P3_7,00102$
                                    638 ;	monostable.c:109: SCL=0;
                                    639 ;	assignBit
      00005E C2 B6            [12]  640 	clr	_P3_6
                                    641 ;	monostable.c:110: nop;
      000060 00               [12]  642 	nop
                                    643 ;	monostable.c:111: }
      000061 22               [24]  644 	ret
                                    645 ;------------------------------------------------------------
                                    646 ;Allocation info for local variables in function 'I2C_DataRead'
                                    647 ;------------------------------------------------------------
                                    648 ;reead                     Allocated to registers r7 
                                    649 ;i                         Allocated to registers r6 
                                    650 ;------------------------------------------------------------
                                    651 ;	monostable.c:112: unsigned char I2C_DataRead(void)///1010 0000     1|0=1...101
                                    652 ;	-----------------------------------------
                                    653 ;	 function I2C_DataRead
                                    654 ;	-----------------------------------------
      000062                        655 _I2C_DataRead:
                                    656 ;	monostable.c:114: unsigned char reead = 0;
      000062 7F 00            [12]  657 	mov	r7,#0x00
                                    658 ;	monostable.c:115: SDA = 1;
                                    659 ;	assignBit
      000064 D2 B7            [12]  660 	setb	_P3_7
                                    661 ;	monostable.c:116: for(int i=0;i<8;i++){
      000066 7E 00            [12]  662 	mov	r6,#0x00
      000068                        663 00105$:
      000068 BE 08 00         [24]  664 	cjne	r6,#0x08,00128$
      00006B                        665 00128$:
      00006B 50 12            [24]  666 	jnc	00103$
                                    667 ;	monostable.c:117: reead = reead << 1;
      00006D 8F 05            [24]  668 	mov	ar5,r7
      00006F ED               [12]  669 	mov	a,r5
      000070 2D               [12]  670 	add	a,r5
      000071 FF               [12]  671 	mov	r7,a
                                    672 ;	monostable.c:118: SCL = 1;
                                    673 ;	assignBit
      000072 D2 B6            [12]  674 	setb	_P3_6
                                    675 ;	monostable.c:119: nop;
      000074 00               [12]  676 	nop
                                    677 ;	monostable.c:120: nop;
      000075 00               [12]  678 	nop
                                    679 ;	monostable.c:121: if(SDA ==1 ){
      000076 30 B7 01         [24]  680 	jnb	_P3_7,00102$
                                    681 ;	monostable.c:122: reead++;
      000079 0F               [12]  682 	inc	r7
      00007A                        683 00102$:
                                    684 ;	monostable.c:124: SCL = 0;
                                    685 ;	assignBit
      00007A C2 B6            [12]  686 	clr	_P3_6
                                    687 ;	monostable.c:116: for(int i=0;i<8;i++){
      00007C 0E               [12]  688 	inc	r6
      00007D 80 E9            [24]  689 	sjmp	00105$
      00007F                        690 00103$:
                                    691 ;	monostable.c:126: SDA = 0;
                                    692 ;	assignBit
      00007F C2 B7            [12]  693 	clr	_P3_7
                                    694 ;	monostable.c:127: return reead;
      000081 8F 82            [24]  695 	mov	dpl, r7
                                    696 ;	monostable.c:128: }
      000083 22               [24]  697 	ret
                                    698 ;------------------------------------------------------------
                                    699 ;Allocation info for local variables in function 'timer0Init'
                                    700 ;------------------------------------------------------------
                                    701 ;	monostable.c:133: void timer0Init(void) {
                                    702 ;	-----------------------------------------
                                    703 ;	 function timer0Init
                                    704 ;	-----------------------------------------
      000084                        705 _timer0Init:
                                    706 ;	monostable.c:135: TMOD |= 0x01; 
      000084 43 89 01         [24]  707 	orl	_TMOD,#0x01
                                    708 ;	monostable.c:137: TH0 = 0xED;  // You may need to adjust this value based on your requirements
      000087 75 8C ED         [24]  709 	mov	_TH0,#0xed
                                    710 ;	monostable.c:138: TL0 = 0xFF;
      00008A 75 8A FF         [24]  711 	mov	_TL0,#0xff
                                    712 ;	monostable.c:139: ET0 = 1;		// Enable Timer 0 overflow interrupt
                                    713 ;	assignBit
      00008D D2 A9            [12]  714 	setb	_ET0
                                    715 ;	monostable.c:140: TR0 = 1;		// Start Timer 0
                                    716 ;	assignBit
      00008F D2 8C            [12]  717 	setb	_TR0
                                    718 ;	monostable.c:141: }
      000091 22               [24]  719 	ret
                                    720 ;------------------------------------------------------------
                                    721 ;Allocation info for local variables in function 'timer1Init'
                                    722 ;------------------------------------------------------------
                                    723 ;	monostable.c:142: volatile void timer1Init(void) {
                                    724 ;	-----------------------------------------
                                    725 ;	 function timer1Init
                                    726 ;	-----------------------------------------
      000092                        727 _timer1Init:
                                    728 ;	monostable.c:144: TMOD |= 0x10; 
      000092 43 89 10         [24]  729 	orl	_TMOD,#0x10
                                    730 ;	monostable.c:146: TH1 = 0xFC;  // You may need to adjust this value based on your requirements
      000095 75 8D FC         [24]  731 	mov	_TH1,#0xfc
                                    732 ;	monostable.c:147: TL1 = 0x17;
      000098 75 8B 17         [24]  733 	mov	_TL1,#0x17
                                    734 ;	monostable.c:148: ET1 = 1;		// Enable Timer 0 overflow interrupt
                                    735 ;	assignBit
      00009B D2 AB            [12]  736 	setb	_ET1
                                    737 ;	monostable.c:149: TR1 = 1;		// Start Timer 0
                                    738 ;	assignBit
      00009D D2 8E            [12]  739 	setb	_TR1
                                    740 ;	monostable.c:150: }
      00009F 22               [24]  741 	ret
                                    742 ;------------------------------------------------------------
                                    743 ;Allocation info for local variables in function 'int0Init'
                                    744 ;------------------------------------------------------------
                                    745 ;	monostable.c:151: void int0Init(void) {
                                    746 ;	-----------------------------------------
                                    747 ;	 function int0Init
                                    748 ;	-----------------------------------------
      0000A0                        749 _int0Init:
                                    750 ;	monostable.c:153: IT0 = 1;
                                    751 ;	assignBit
      0000A0 D2 88            [12]  752 	setb	_IT0
                                    753 ;	monostable.c:155: EX0 = 1;
                                    754 ;	assignBit
      0000A2 D2 A8            [12]  755 	setb	_EX0
                                    756 ;	monostable.c:157: EA = 1;
                                    757 ;	assignBit
      0000A4 D2 AF            [12]  758 	setb	_EA
                                    759 ;	monostable.c:158: }
      0000A6 22               [24]  760 	ret
                                    761 ;------------------------------------------------------------
                                    762 ;Allocation info for local variables in function 'Timer0_ISR'
                                    763 ;------------------------------------------------------------
                                    764 ;	monostable.c:159: void Timer0_ISR(void) __interrupt (1)
                                    765 ;	-----------------------------------------
                                    766 ;	 function Timer0_ISR
                                    767 ;	-----------------------------------------
      0000A7                        768 _Timer0_ISR:
      0000A7 C0*00            [24]  769 	push	bits
      0000A9 C0 E0            [24]  770 	push	acc
      0000AB C0 F0            [24]  771 	push	b
      0000AD C0 82            [24]  772 	push	dpl
      0000AF C0 83            [24]  773 	push	dph
      0000B1 C0 07            [24]  774 	push	(0+7)
      0000B3 C0 06            [24]  775 	push	(0+6)
      0000B5 C0 05            [24]  776 	push	(0+5)
      0000B7 C0 04            [24]  777 	push	(0+4)
      0000B9 C0 03            [24]  778 	push	(0+3)
      0000BB C0 02            [24]  779 	push	(0+2)
      0000BD C0 01            [24]  780 	push	(0+1)
      0000BF C0 00            [24]  781 	push	(0+0)
      0000C1 C0 D0            [24]  782 	push	psw
      0000C3 75 D0 00         [24]  783 	mov	psw,#0x00
                                    784 ;	monostable.c:162: TH0 = 0xED;  // You may need to adjust this value based on your requirements
      0000C6 75 8C ED         [24]  785 	mov	_TH0,#0xed
                                    786 ;	monostable.c:163: TL0 = 0xFF;
      0000C9 75 8A FF         [24]  787 	mov	_TL0,#0xff
                                    788 ;	monostable.c:165: currentDigit++;
      0000CC E5*10            [12]  789 	mov	a,_currentDigit
      0000CE 04               [12]  790 	inc	a
      0000CF F5*10            [12]  791 	mov	_currentDigit,a
                                    792 ;	monostable.c:168: if (currentDigit > 3) {
      0000D1 E5*10            [12]  793 	mov	a,_currentDigit
      0000D3 24 FC            [12]  794 	add	a,#0xff - 0x03
      0000D5 50 03            [24]  795 	jnc	00102$
                                    796 ;	monostable.c:169: currentDigit = 0;
      0000D7 75*10 00         [24]  797 	mov	_currentDigit,#0x00
      0000DA                        798 00102$:
                                    799 ;	monostable.c:171: P2 = 0xff;
      0000DA 75 A0 FF         [24]  800 	mov	_P2,#0xff
                                    801 ;	monostable.c:172: if(P1_0==0){
      0000DD 20 90 0E         [24]  802 	jb	_P1_0,00104$
                                    803 ;	monostable.c:173: dispalay_data = interrupt_counter;
      0000E0 85*19*11         [24]  804 	mov	_dispalay_data,_interrupt_counter
      0000E3 85*1A*12         [24]  805 	mov	(_dispalay_data + 1),(_interrupt_counter + 1)
      0000E6 85*1B*13         [24]  806 	mov	(_dispalay_data + 2),(_interrupt_counter + 2)
      0000E9 85*1C*14         [24]  807 	mov	(_dispalay_data + 3),(_interrupt_counter + 3)
      0000EC 80 0C            [24]  808 	sjmp	00105$
      0000EE                        809 00104$:
                                    810 ;	monostable.c:175: dispalay_data = delayTime;	
      0000EE 85*0E*11         [24]  811 	mov	_dispalay_data,_delayTime
      0000F1 85*0F*12         [24]  812 	mov	(_dispalay_data + 1),(_delayTime + 1)
      0000F4 75*13 00         [24]  813 	mov	(_dispalay_data + 2),#0x00
      0000F7 75*14 00         [24]  814 	mov	(_dispalay_data + 3),#0x00
      0000FA                        815 00105$:
                                    816 ;	monostable.c:179: switch (currentDigit) {
      0000FA E5*10            [12]  817 	mov	a,_currentDigit
      0000FC FF               [12]  818 	mov	r7,a
      0000FD 24 FC            [12]  819 	add	a,#0xff - 0x03
      0000FF 50 03            [24]  820 	jnc	00133$
      000101 02r02r1D         [24]  821 	ljmp	00111$
      000104                        822 00133$:
      000104 EF               [12]  823 	mov	a,r7
      000105 2F               [12]  824 	add	a,r7
      000106 2F               [12]  825 	add	a,r7
      000107 90r01r0B         [24]  826 	mov	dptr,#00134$
      00010A 73               [24]  827 	jmp	@a+dptr
      00010B                        828 00134$:
      00010B 02r01r17         [24]  829 	ljmp	00106$
      00010E 02r01r45         [24]  830 	ljmp	00107$
      000111 02r01r8E         [24]  831 	ljmp	00108$
      000114 02r01rD6         [24]  832 	ljmp	00109$
                                    833 ;	monostable.c:180: case 0:
      000117                        834 00106$:
                                    835 ;	monostable.c:181: DISP1 = 1;
                                    836 ;	assignBit
      000117 D2 91            [12]  837 	setb	_P1_1
                                    838 ;	monostable.c:182: DISP2 = DISP3 = DISP4 = 0;
                                    839 ;	assignBit
      000119 C2 94            [12]  840 	clr	_P1_4
                                    841 ;	assignBit
      00011B A2 94            [12]  842 	mov	c,_P1_4
      00011D 92 93            [24]  843 	mov	_P1_3,c
                                    844 ;	assignBit
      00011F A2 93            [12]  845 	mov	c,_P1_3
      000121 92 92            [24]  846 	mov	_P1_2,c
                                    847 ;	monostable.c:183: displayDigit(dispalay_data%10);  // Change this value based on the desired number to display
      000123 75*00 0A         [24]  848 	mov	__modulong_PARM_2,#0x0a
      000126 E4               [12]  849 	clr	a
      000127 F5*01            [12]  850 	mov	(__modulong_PARM_2 + 1),a
      000129 F5*02            [12]  851 	mov	(__modulong_PARM_2 + 2),a
      00012B F5*03            [12]  852 	mov	(__modulong_PARM_2 + 3),a
      00012D 85*11 82         [24]  853 	mov	dpl, _dispalay_data
      000130 85*12 83         [24]  854 	mov	dph, (_dispalay_data + 1)
      000133 85*13 F0         [24]  855 	mov	b, (_dispalay_data + 2)
      000136 E5*14            [12]  856 	mov	a, (_dispalay_data + 3)
      000138 12r00r00         [24]  857 	lcall	__modulong
      00013B AC 82            [24]  858 	mov	r4, dpl
      00013D 8C 82            [24]  859 	mov	dpl,r4
      00013F 12r00r00         [24]  860 	lcall	_displayDigit
                                    861 ;	monostable.c:184: break;
      000142 02r02r1D         [24]  862 	ljmp	00111$
                                    863 ;	monostable.c:185: case 1:
      000145                        864 00107$:
                                    865 ;	monostable.c:186: DISP2 = 1;
                                    866 ;	assignBit
      000145 D2 92            [12]  867 	setb	_P1_2
                                    868 ;	monostable.c:187: DISP1 = DISP3 = DISP4 = 0;
                                    869 ;	assignBit
      000147 C2 94            [12]  870 	clr	_P1_4
                                    871 ;	assignBit
      000149 A2 94            [12]  872 	mov	c,_P1_4
      00014B 92 93            [24]  873 	mov	_P1_3,c
                                    874 ;	assignBit
      00014D A2 93            [12]  875 	mov	c,_P1_3
      00014F 92 91            [24]  876 	mov	_P1_1,c
                                    877 ;	monostable.c:188: displayDigit((dispalay_data/10)%10);  // Change this value based on the desired number to display
      000151 75*00 0A         [24]  878 	mov	__divulong_PARM_2,#0x0a
      000154 E4               [12]  879 	clr	a
      000155 F5*01            [12]  880 	mov	(__divulong_PARM_2 + 1),a
      000157 F5*02            [12]  881 	mov	(__divulong_PARM_2 + 2),a
      000159 F5*03            [12]  882 	mov	(__divulong_PARM_2 + 3),a
      00015B 85*11 82         [24]  883 	mov	dpl, _dispalay_data
      00015E 85*12 83         [24]  884 	mov	dph, (_dispalay_data + 1)
      000161 85*13 F0         [24]  885 	mov	b, (_dispalay_data + 2)
      000164 E5*14            [12]  886 	mov	a, (_dispalay_data + 3)
      000166 12r00r00         [24]  887 	lcall	__divulong
      000169 AC 82            [24]  888 	mov	r4, dpl
      00016B AD 83            [24]  889 	mov	r5, dph
      00016D AE F0            [24]  890 	mov	r6, b
      00016F FF               [12]  891 	mov	r7, a
      000170 75*00 0A         [24]  892 	mov	__modulong_PARM_2,#0x0a
      000173 E4               [12]  893 	clr	a
      000174 F5*01            [12]  894 	mov	(__modulong_PARM_2 + 1),a
      000176 F5*02            [12]  895 	mov	(__modulong_PARM_2 + 2),a
      000178 F5*03            [12]  896 	mov	(__modulong_PARM_2 + 3),a
      00017A 8C 82            [24]  897 	mov	dpl, r4
      00017C 8D 83            [24]  898 	mov	dph, r5
      00017E 8E F0            [24]  899 	mov	b, r6
      000180 EF               [12]  900 	mov	a, r7
      000181 12r00r00         [24]  901 	lcall	__modulong
      000184 AC 82            [24]  902 	mov	r4, dpl
      000186 8C 82            [24]  903 	mov	dpl,r4
      000188 12r00r00         [24]  904 	lcall	_displayDigit
                                    905 ;	monostable.c:189: break;
      00018B 02r02r1D         [24]  906 	ljmp	00111$
                                    907 ;	monostable.c:190: case 2:
      00018E                        908 00108$:
                                    909 ;	monostable.c:191: DISP3 = 1;
                                    910 ;	assignBit
      00018E D2 93            [12]  911 	setb	_P1_3
                                    912 ;	monostable.c:192: DISP1 = DISP2 = DISP4 = 0;
                                    913 ;	assignBit
      000190 C2 94            [12]  914 	clr	_P1_4
                                    915 ;	assignBit
      000192 A2 94            [12]  916 	mov	c,_P1_4
      000194 92 92            [24]  917 	mov	_P1_2,c
                                    918 ;	assignBit
      000196 A2 92            [12]  919 	mov	c,_P1_2
      000198 92 91            [24]  920 	mov	_P1_1,c
                                    921 ;	monostable.c:193: displayDigit((dispalay_data/100)%10);  // Change this value based on the desired number to display
      00019A 75*00 64         [24]  922 	mov	__divulong_PARM_2,#0x64
      00019D E4               [12]  923 	clr	a
      00019E F5*01            [12]  924 	mov	(__divulong_PARM_2 + 1),a
      0001A0 F5*02            [12]  925 	mov	(__divulong_PARM_2 + 2),a
      0001A2 F5*03            [12]  926 	mov	(__divulong_PARM_2 + 3),a
      0001A4 85*11 82         [24]  927 	mov	dpl, _dispalay_data
      0001A7 85*12 83         [24]  928 	mov	dph, (_dispalay_data + 1)
      0001AA 85*13 F0         [24]  929 	mov	b, (_dispalay_data + 2)
      0001AD E5*14            [12]  930 	mov	a, (_dispalay_data + 3)
      0001AF 12r00r00         [24]  931 	lcall	__divulong
      0001B2 AC 82            [24]  932 	mov	r4, dpl
      0001B4 AD 83            [24]  933 	mov	r5, dph
      0001B6 AE F0            [24]  934 	mov	r6, b
      0001B8 FF               [12]  935 	mov	r7, a
      0001B9 75*00 0A         [24]  936 	mov	__modulong_PARM_2,#0x0a
      0001BC E4               [12]  937 	clr	a
      0001BD F5*01            [12]  938 	mov	(__modulong_PARM_2 + 1),a
      0001BF F5*02            [12]  939 	mov	(__modulong_PARM_2 + 2),a
      0001C1 F5*03            [12]  940 	mov	(__modulong_PARM_2 + 3),a
      0001C3 8C 82            [24]  941 	mov	dpl, r4
      0001C5 8D 83            [24]  942 	mov	dph, r5
      0001C7 8E F0            [24]  943 	mov	b, r6
      0001C9 EF               [12]  944 	mov	a, r7
      0001CA 12r00r00         [24]  945 	lcall	__modulong
      0001CD AC 82            [24]  946 	mov	r4, dpl
      0001CF 8C 82            [24]  947 	mov	dpl,r4
      0001D1 12r00r00         [24]  948 	lcall	_displayDigit
                                    949 ;	monostable.c:194: break;
                                    950 ;	monostable.c:195: case 3:
      0001D4 80 47            [24]  951 	sjmp	00111$
      0001D6                        952 00109$:
                                    953 ;	monostable.c:196: DISP4 = 1;
                                    954 ;	assignBit
      0001D6 D2 94            [12]  955 	setb	_P1_4
                                    956 ;	monostable.c:197: DISP1 = DISP2 = DISP3 = 0;
                                    957 ;	assignBit
      0001D8 C2 93            [12]  958 	clr	_P1_3
                                    959 ;	assignBit
      0001DA A2 93            [12]  960 	mov	c,_P1_3
      0001DC 92 92            [24]  961 	mov	_P1_2,c
                                    962 ;	assignBit
      0001DE A2 92            [12]  963 	mov	c,_P1_2
      0001E0 92 91            [24]  964 	mov	_P1_1,c
                                    965 ;	monostable.c:198: displayDigit((dispalay_data/1000)%10);  // Change this value based on the desired number to display
      0001E2 75*00 E8         [24]  966 	mov	__divulong_PARM_2,#0xe8
      0001E5 75*01 03         [24]  967 	mov	(__divulong_PARM_2 + 1),#0x03
      0001E8 E4               [12]  968 	clr	a
      0001E9 F5*02            [12]  969 	mov	(__divulong_PARM_2 + 2),a
      0001EB F5*03            [12]  970 	mov	(__divulong_PARM_2 + 3),a
      0001ED 85*11 82         [24]  971 	mov	dpl, _dispalay_data
      0001F0 85*12 83         [24]  972 	mov	dph, (_dispalay_data + 1)
      0001F3 85*13 F0         [24]  973 	mov	b, (_dispalay_data + 2)
      0001F6 E5*14            [12]  974 	mov	a, (_dispalay_data + 3)
      0001F8 12r00r00         [24]  975 	lcall	__divulong
      0001FB AC 82            [24]  976 	mov	r4, dpl
      0001FD AD 83            [24]  977 	mov	r5, dph
      0001FF AE F0            [24]  978 	mov	r6, b
      000201 FF               [12]  979 	mov	r7, a
      000202 75*00 0A         [24]  980 	mov	__modulong_PARM_2,#0x0a
      000205 E4               [12]  981 	clr	a
      000206 F5*01            [12]  982 	mov	(__modulong_PARM_2 + 1),a
      000208 F5*02            [12]  983 	mov	(__modulong_PARM_2 + 2),a
      00020A F5*03            [12]  984 	mov	(__modulong_PARM_2 + 3),a
      00020C 8C 82            [24]  985 	mov	dpl, r4
      00020E 8D 83            [24]  986 	mov	dph, r5
      000210 8E F0            [24]  987 	mov	b, r6
      000212 EF               [12]  988 	mov	a, r7
      000213 12r00r00         [24]  989 	lcall	__modulong
      000216 AC 82            [24]  990 	mov	r4, dpl
      000218 8C 82            [24]  991 	mov	dpl,r4
      00021A 12r00r00         [24]  992 	lcall	_displayDigit
                                    993 ;	monostable.c:200: }
      00021D                        994 00111$:
                                    995 ;	monostable.c:202: }
      00021D D0 D0            [24]  996 	pop	psw
      00021F D0 00            [24]  997 	pop	(0+0)
      000221 D0 01            [24]  998 	pop	(0+1)
      000223 D0 02            [24]  999 	pop	(0+2)
      000225 D0 03            [24] 1000 	pop	(0+3)
      000227 D0 04            [24] 1001 	pop	(0+4)
      000229 D0 05            [24] 1002 	pop	(0+5)
      00022B D0 06            [24] 1003 	pop	(0+6)
      00022D D0 07            [24] 1004 	pop	(0+7)
      00022F D0 83            [24] 1005 	pop	dph
      000231 D0 82            [24] 1006 	pop	dpl
      000233 D0 F0            [24] 1007 	pop	b
      000235 D0 E0            [24] 1008 	pop	acc
      000237 D0*00            [24] 1009 	pop	bits
      000239 32               [24] 1010 	reti
                                   1011 ;------------------------------------------------------------
                                   1012 ;Allocation info for local variables in function 'delay_ms'
                                   1013 ;------------------------------------------------------------
                                   1014 ;ms                        Allocated to registers r6 r7 
                                   1015 ;i                         Allocated to registers r4 r5 
                                   1016 ;j                         Allocated to registers r2 r3 
                                   1017 ;------------------------------------------------------------
                                   1018 ;	monostable.c:205: volatile void delay_ms(int ms) {
                                   1019 ;	-----------------------------------------
                                   1020 ;	 function delay_ms
                                   1021 ;	-----------------------------------------
      00023A                       1022 _delay_ms:
      00023A AE 82            [24] 1023 	mov	r6, dpl
      00023C AF 83            [24] 1024 	mov	r7, dph
                                   1025 ;	monostable.c:207: for (i = 0; i < ms; i++){
      00023E 7C 00            [12] 1026 	mov	r4,#0x00
      000240 7D 00            [12] 1027 	mov	r5,#0x00
      000242                       1028 00107$:
      000242 8E 02            [24] 1029 	mov	ar2,r6
      000244 8F 03            [24] 1030 	mov	ar3,r7
      000246 C3               [12] 1031 	clr	c
      000247 EC               [12] 1032 	mov	a,r4
      000248 9A               [12] 1033 	subb	a,r2
      000249 ED               [12] 1034 	mov	a,r5
      00024A 9B               [12] 1035 	subb	a,r3
      00024B 50 14            [24] 1036 	jnc	00109$
                                   1037 ;	monostable.c:208: for (j = 0; j < 112; j++){
      00024D 7A 70            [12] 1038 	mov	r2,#0x70
      00024F 7B 00            [12] 1039 	mov	r3,#0x00
      000251                       1040 00105$:
      000251 1A               [12] 1041 	dec	r2
      000252 BA FF 01         [24] 1042 	cjne	r2,#0xff,00138$
      000255 1B               [12] 1043 	dec	r3
      000256                       1044 00138$:
      000256 EA               [12] 1045 	mov	a,r2
      000257 4B               [12] 1046 	orl	a,r3
      000258 70 F7            [24] 1047 	jnz	00105$
                                   1048 ;	monostable.c:207: for (i = 0; i < ms; i++){
      00025A 0C               [12] 1049 	inc	r4
      00025B BC 00 E4         [24] 1050 	cjne	r4,#0x00,00107$
      00025E 0D               [12] 1051 	inc	r5
      00025F 80 E1            [24] 1052 	sjmp	00107$
      000261                       1053 00109$:
                                   1054 ;	monostable.c:213: }
      000261 22               [24] 1055 	ret
                                   1056 ;------------------------------------------------------------
                                   1057 ;Allocation info for local variables in function 'int_ISR'
                                   1058 ;------------------------------------------------------------
                                   1059 ;	monostable.c:216: void int_ISR(void) __interrupt (0)
                                   1060 ;	-----------------------------------------
                                   1061 ;	 function int_ISR
                                   1062 ;	-----------------------------------------
      000262                       1063 _int_ISR:
      000262 C0*00            [24] 1064 	push	bits
      000264 C0 E0            [24] 1065 	push	acc
      000266 C0 F0            [24] 1066 	push	b
      000268 C0 82            [24] 1067 	push	dpl
      00026A C0 83            [24] 1068 	push	dph
      00026C C0 07            [24] 1069 	push	(0+7)
      00026E C0 06            [24] 1070 	push	(0+6)
      000270 C0 05            [24] 1071 	push	(0+5)
      000272 C0 04            [24] 1072 	push	(0+4)
      000274 C0 03            [24] 1073 	push	(0+3)
      000276 C0 02            [24] 1074 	push	(0+2)
      000278 C0 01            [24] 1075 	push	(0+1)
      00027A C0 00            [24] 1076 	push	(0+0)
      00027C C0 D0            [24] 1077 	push	psw
      00027E 75 D0 00         [24] 1078 	mov	psw,#0x00
                                   1079 ;	monostable.c:218: P1_0 = 0;
                                   1080 ;	assignBit
      000281 C2 90            [12] 1081 	clr	_P1_0
                                   1082 ;	monostable.c:220: timer1Init();
      000283 12r00r92         [24] 1083 	lcall	_timer1Init
                                   1084 ;	monostable.c:222: }
      000286 D0 D0            [24] 1085 	pop	psw
      000288 D0 00            [24] 1086 	pop	(0+0)
      00028A D0 01            [24] 1087 	pop	(0+1)
      00028C D0 02            [24] 1088 	pop	(0+2)
      00028E D0 03            [24] 1089 	pop	(0+3)
      000290 D0 04            [24] 1090 	pop	(0+4)
      000292 D0 05            [24] 1091 	pop	(0+5)
      000294 D0 06            [24] 1092 	pop	(0+6)
      000296 D0 07            [24] 1093 	pop	(0+7)
      000298 D0 83            [24] 1094 	pop	dph
      00029A D0 82            [24] 1095 	pop	dpl
      00029C D0 F0            [24] 1096 	pop	b
      00029E D0 E0            [24] 1097 	pop	acc
      0002A0 D0*00            [24] 1098 	pop	bits
      0002A2 32               [24] 1099 	reti
                                   1100 ;------------------------------------------------------------
                                   1101 ;Allocation info for local variables in function 'Timer1_ISR'
                                   1102 ;------------------------------------------------------------
                                   1103 ;	monostable.c:223: void Timer1_ISR(void) __interrupt (3){
                                   1104 ;	-----------------------------------------
                                   1105 ;	 function Timer1_ISR
                                   1106 ;	-----------------------------------------
      0002A3                       1107 _Timer1_ISR:
      0002A3 C0 E0            [24] 1108 	push	acc
      0002A5 C0 07            [24] 1109 	push	ar7
      0002A7 C0 06            [24] 1110 	push	ar6
      0002A9 C0 05            [24] 1111 	push	ar5
      0002AB C0 04            [24] 1112 	push	ar4
      0002AD C0 D0            [24] 1113 	push	psw
      0002AF 75 D0 00         [24] 1114 	mov	psw,#0x00
                                   1115 ;	monostable.c:224: TH1 = 0xFC;  // You may need to adjust this value based on your requirements
      0002B2 75 8D FC         [24] 1116 	mov	_TH1,#0xfc
                                   1117 ;	monostable.c:225: TL1 = 0x17;
      0002B5 75 8B 17         [24] 1118 	mov	_TL1,#0x17
                                   1119 ;	monostable.c:226: interrupt_counter++;
      0002B8 05*19            [12] 1120 	inc	_interrupt_counter
      0002BA E4               [12] 1121 	clr	a
      0002BB B5*19 0C         [24] 1122 	cjne	a,_interrupt_counter,00111$
      0002BE 05*1A            [12] 1123 	inc	(_interrupt_counter + 1)
      0002C0 B5*1A 07         [24] 1124 	cjne	a,(_interrupt_counter + 1),00111$
      0002C3 05*1B            [12] 1125 	inc	(_interrupt_counter + 2)
      0002C5 B5*1B 02         [24] 1126 	cjne	a,(_interrupt_counter + 2),00111$
      0002C8 05*1C            [12] 1127 	inc	(_interrupt_counter + 3)
      0002CA                       1128 00111$:
                                   1129 ;	monostable.c:227: if(interrupt_counter >= delayTime){
      0002CA AC*0E            [24] 1130 	mov	r4,_delayTime
      0002CC AD*0F            [24] 1131 	mov	r5,(_delayTime + 1)
      0002CE 7E 00            [12] 1132 	mov	r6,#0x00
      0002D0 7F 00            [12] 1133 	mov	r7,#0x00
      0002D2 C3               [12] 1134 	clr	c
      0002D3 E5*19            [12] 1135 	mov	a,_interrupt_counter
      0002D5 9C               [12] 1136 	subb	a,r4
      0002D6 E5*1A            [12] 1137 	mov	a,(_interrupt_counter + 1)
      0002D8 9D               [12] 1138 	subb	a,r5
      0002D9 E5*1B            [12] 1139 	mov	a,(_interrupt_counter + 2)
      0002DB 9E               [12] 1140 	subb	a,r6
      0002DC E5*1C            [12] 1141 	mov	a,(_interrupt_counter + 3)
      0002DE 9F               [12] 1142 	subb	a,r7
      0002DF 40 0D            [24] 1143 	jc	00103$
                                   1144 ;	monostable.c:228: P1_0 =1;
                                   1145 ;	assignBit
      0002E1 D2 90            [12] 1146 	setb	_P1_0
                                   1147 ;	monostable.c:229: TR1 = 0;
                                   1148 ;	assignBit
      0002E3 C2 8E            [12] 1149 	clr	_TR1
                                   1150 ;	monostable.c:230: interrupt_counter = 0;
      0002E5 E4               [12] 1151 	clr	a
      0002E6 F5*19            [12] 1152 	mov	_interrupt_counter,a
      0002E8 F5*1A            [12] 1153 	mov	(_interrupt_counter + 1),a
      0002EA F5*1B            [12] 1154 	mov	(_interrupt_counter + 2),a
      0002EC F5*1C            [12] 1155 	mov	(_interrupt_counter + 3),a
      0002EE                       1156 00103$:
                                   1157 ;	monostable.c:232: }
      0002EE D0 D0            [24] 1158 	pop	psw
      0002F0 D0 04            [24] 1159 	pop	ar4
      0002F2 D0 05            [24] 1160 	pop	ar5
      0002F4 D0 06            [24] 1161 	pop	ar6
      0002F6 D0 07            [24] 1162 	pop	ar7
      0002F8 D0 E0            [24] 1163 	pop	acc
      0002FA 32               [24] 1164 	reti
                                   1165 ;	eliminated unneeded push/pop dpl
                                   1166 ;	eliminated unneeded push/pop dph
                                   1167 ;	eliminated unneeded push/pop b
                                   1168 ;------------------------------------------------------------
                                   1169 ;Allocation info for local variables in function 'main'
                                   1170 ;------------------------------------------------------------
                                   1171 ;rx_first_byte             Allocated to registers r7 
                                   1172 ;rx_second_byte            Allocated to registers r6 
                                   1173 ;txfirstByte               Allocated to registers r6 
                                   1174 ;txsecondByte              Allocated to registers r7 
                                   1175 ;------------------------------------------------------------
                                   1176 ;	monostable.c:235: void main(void)
                                   1177 ;	-----------------------------------------
                                   1178 ;	 function main
                                   1179 ;	-----------------------------------------
      0002FB                       1180 _main:
                                   1181 ;	monostable.c:263: I2C_Start();
      0002FB 12r00r1A         [24] 1182 	lcall	_I2C_Start
                                   1183 ;	monostable.c:264: I2C_DataWrite(0xA0);
      0002FE 75 82 A0         [24] 1184 	mov	dpl, #0xa0
      000301 12r00r36         [24] 1185 	lcall	_I2C_DataWrite
                                   1186 ;	monostable.c:265: I2C_DataWrite(0x00);
      000304 75 82 00         [24] 1187 	mov	dpl, #0x00
      000307 12r00r36         [24] 1188 	lcall	_I2C_DataWrite
                                   1189 ;	monostable.c:266: I2C_DataWrite(0x01);
      00030A 75 82 01         [24] 1190 	mov	dpl, #0x01
      00030D 12r00r36         [24] 1191 	lcall	_I2C_DataWrite
                                   1192 ;	monostable.c:267: I2C_Start();
      000310 12r00r1A         [24] 1193 	lcall	_I2C_Start
                                   1194 ;	monostable.c:268: I2C_DataWrite(0xA1);
      000313 75 82 A1         [24] 1195 	mov	dpl, #0xa1
      000316 12r00r36         [24] 1196 	lcall	_I2C_DataWrite
                                   1197 ;	monostable.c:269: rx_first_byte = I2C_DataRead();
      000319 12r00r62         [24] 1198 	lcall	_I2C_DataRead
      00031C AF 82            [24] 1199 	mov	r7, dpl
                                   1200 ;	monostable.c:270: acknowledge();
      00031E C0 07            [24] 1201 	push	ar7
      000320 12r00r30         [24] 1202 	lcall	_acknowledge
                                   1203 ;	monostable.c:271: rx_second_byte = I2C_DataRead();
      000323 12r00r62         [24] 1204 	lcall	_I2C_DataRead
      000326 AE 82            [24] 1205 	mov	r6, dpl
                                   1206 ;	monostable.c:272: acknowledge();
      000328 C0 06            [24] 1207 	push	ar6
      00032A 12r00r30         [24] 1208 	lcall	_acknowledge
                                   1209 ;	monostable.c:273: I2C_Stop();
      00032D 12r00r26         [24] 1210 	lcall	_I2C_Stop
      000330 D0 06            [24] 1211 	pop	ar6
      000332 D0 07            [24] 1212 	pop	ar7
                                   1213 ;	monostable.c:285: delayTime = (rx_first_byte << 8) | rx_second_byte;
      000334 8F 05            [24] 1214 	mov	ar5,r7
      000336 E4               [12] 1215 	clr	a
      000337 FF               [12] 1216 	mov	r7,a
      000338 FC               [12] 1217 	mov	r4,a
      000339 EE               [12] 1218 	mov	a,r6
      00033A 4F               [12] 1219 	orl	a,r7
      00033B F5*0E            [12] 1220 	mov	_delayTime,a
      00033D EC               [12] 1221 	mov	a,r4
      00033E 4D               [12] 1222 	orl	a,r5
      00033F F5*0F            [12] 1223 	mov	(_delayTime + 1),a
                                   1224 ;	monostable.c:288: timer0Init();
      000341 12r00r84         [24] 1225 	lcall	_timer0Init
                                   1226 ;	monostable.c:289: delay_ms(1000);
      000344 90 03 E8         [24] 1227 	mov	dptr,#0x03e8
      000347 12r02r3A         [24] 1228 	lcall	_delay_ms
                                   1229 ;	monostable.c:291: int0Init();
      00034A 12r00rA0         [24] 1230 	lcall	_int0Init
                                   1231 ;	monostable.c:293: while (1)
      00034D                       1232 00139$:
                                   1233 ;	monostable.c:297: if (BUTTON1 == 0 ) {  // Button is pressed
      00034D 30 B0 03         [24] 1234 	jnb	_P3_0,00245$
      000350 02r03rD0         [24] 1235 	ljmp	00115$
      000353                       1236 00245$:
                                   1237 ;	monostable.c:298: if(delayTime > 9999){
      000353 C3               [12] 1238 	clr	c
      000354 74 0F            [12] 1239 	mov	a,#0x0f
      000356 95*0E            [12] 1240 	subb	a,_delayTime
      000358 74 27            [12] 1241 	mov	a,#0x27
      00035A 95*0F            [12] 1242 	subb	a,(_delayTime + 1)
      00035C 50 07            [24] 1243 	jnc	00102$
                                   1244 ;	monostable.c:299: delayTime =0;
      00035E E4               [12] 1245 	clr	a
      00035F F5*0E            [12] 1246 	mov	_delayTime,a
      000361 F5*0F            [12] 1247 	mov	(_delayTime + 1),a
      000363 80 0B            [24] 1248 	sjmp	00103$
      000365                       1249 00102$:
                                   1250 ;	monostable.c:302: delayTime +=1;
      000365 74 01            [12] 1251 	mov	a,#0x01
      000367 25*0E            [12] 1252 	add	a, _delayTime
      000369 F5*0E            [12] 1253 	mov	_delayTime,a
      00036B E4               [12] 1254 	clr	a
      00036C 35*0F            [12] 1255 	addc	a, (_delayTime + 1)
      00036E F5*0F            [12] 1256 	mov	(_delayTime + 1),a
      000370                       1257 00103$:
                                   1258 ;	monostable.c:305: delay_ms(50);  // Debouncing delay
      000370 90 00 32         [24] 1259 	mov	dptr,#0x0032
      000373 12r02r3A         [24] 1260 	lcall	_delay_ms
                                   1261 ;	monostable.c:306: while (BUTTON1 == 0) {
      000376                       1262 00111$:
      000376 20 B0 60         [24] 1263 	jb	_P3_0,00116$
                                   1264 ;	monostable.c:307: if(longPressTime > 5000-acceleration){
      000379 74 88            [12] 1265 	mov	a,#0x88
      00037B C3               [12] 1266 	clr	c
      00037C 95*17            [12] 1267 	subb	a,_acceleration
      00037E FE               [12] 1268 	mov	r6,a
      00037F 74 13            [12] 1269 	mov	a,#0x13
      000381 95*18            [12] 1270 	subb	a,(_acceleration + 1)
      000383 FF               [12] 1271 	mov	r7,a
      000384 C3               [12] 1272 	clr	c
      000385 EE               [12] 1273 	mov	a,r6
      000386 95*15            [12] 1274 	subb	a,_longPressTime
      000388 EF               [12] 1275 	mov	a,r7
      000389 95*16            [12] 1276 	subb	a,(_longPressTime + 1)
      00038B 50 39            [24] 1277 	jnc	00110$
                                   1278 ;	monostable.c:308: longPressTime = 0;
      00038D E4               [12] 1279 	clr	a
      00038E F5*15            [12] 1280 	mov	_longPressTime,a
      000390 F5*16            [12] 1281 	mov	(_longPressTime + 1),a
                                   1282 ;	monostable.c:310: if(delayTime > 9999){
      000392 C3               [12] 1283 	clr	c
      000393 74 0F            [12] 1284 	mov	a,#0x0f
      000395 95*0E            [12] 1285 	subb	a,_delayTime
      000397 74 27            [12] 1286 	mov	a,#0x27
      000399 95*0F            [12] 1287 	subb	a,(_delayTime + 1)
      00039B 50 08            [24] 1288 	jnc	00105$
                                   1289 ;	monostable.c:311: delayTime =1 ;
      00039D 75*0E 01         [24] 1290 	mov	_delayTime,#0x01
      0003A0 75*0F 00         [24] 1291 	mov	(_delayTime + 1),#0x00
      0003A3 80 0B            [24] 1292 	sjmp	00106$
      0003A5                       1293 00105$:
                                   1294 ;	monostable.c:314: delayTime +=1;
      0003A5 74 01            [12] 1295 	mov	a,#0x01
      0003A7 25*0E            [12] 1296 	add	a, _delayTime
      0003A9 F5*0E            [12] 1297 	mov	_delayTime,a
      0003AB E4               [12] 1298 	clr	a
      0003AC 35*0F            [12] 1299 	addc	a, (_delayTime + 1)
      0003AE F5*0F            [12] 1300 	mov	(_delayTime + 1),a
      0003B0                       1301 00106$:
                                   1302 ;	monostable.c:316: if(acceleration < 4500){
      0003B0 C3               [12] 1303 	clr	c
      0003B1 E5*17            [12] 1304 	mov	a,_acceleration
      0003B3 94 94            [12] 1305 	subb	a,#0x94
      0003B5 E5*18            [12] 1306 	mov	a,(_acceleration + 1)
      0003B7 94 11            [12] 1307 	subb	a,#0x11
      0003B9 50 0B            [24] 1308 	jnc	00110$
                                   1309 ;	monostable.c:317: acceleration = 30 +acceleration;
      0003BB 74 1E            [12] 1310 	mov	a,#0x1e
      0003BD 25*17            [12] 1311 	add	a, _acceleration
      0003BF F5*17            [12] 1312 	mov	_acceleration,a
      0003C1 E4               [12] 1313 	clr	a
      0003C2 35*18            [12] 1314 	addc	a, (_acceleration + 1)
      0003C4 F5*18            [12] 1315 	mov	(_acceleration + 1),a
      0003C6                       1316 00110$:
                                   1317 ;	monostable.c:320: longPressTime++;
      0003C6 05*15            [12] 1318 	inc	_longPressTime
      0003C8 E4               [12] 1319 	clr	a
      0003C9 B5*15 AA         [24] 1320 	cjne	a,_longPressTime,00111$
      0003CC 05*16            [12] 1321 	inc	(_longPressTime + 1)
      0003CE 80 A6            [24] 1322 	sjmp	00111$
      0003D0                       1323 00115$:
                                   1324 ;	monostable.c:326: longPressTime = 0;
      0003D0 E4               [12] 1325 	clr	a
      0003D1 F5*15            [12] 1326 	mov	_longPressTime,a
      0003D3 F5*16            [12] 1327 	mov	(_longPressTime + 1),a
                                   1328 ;	monostable.c:327: acceleration =  0;
      0003D5 F5*17            [12] 1329 	mov	_acceleration,a
      0003D7 F5*18            [12] 1330 	mov	(_acceleration + 1),a
      0003D9                       1331 00116$:
                                   1332 ;	monostable.c:329: if (BUTTON2 == 0) {  // Button is pressed
      0003D9 20 B1 79         [24] 1333 	jb	_P3_1,00131$
                                   1334 ;	monostable.c:330: if(delayTime <= 1){
      0003DC C3               [12] 1335 	clr	c
      0003DD 74 01            [12] 1336 	mov	a,#0x01
      0003DF 95*0E            [12] 1337 	subb	a,_delayTime
      0003E1 E4               [12] 1338 	clr	a
      0003E2 95*0F            [12] 1339 	subb	a,(_delayTime + 1)
      0003E4 40 08            [24] 1340 	jc	00118$
                                   1341 ;	monostable.c:331: delayTime = 9999;
      0003E6 75*0E 0F         [24] 1342 	mov	_delayTime,#0x0f
      0003E9 75*0F 27         [24] 1343 	mov	(_delayTime + 1),#0x27
      0003EC 80 09            [24] 1344 	sjmp	00119$
      0003EE                       1345 00118$:
                                   1346 ;	monostable.c:333: delayTime-=1;
      0003EE 15*0E            [12] 1347 	dec	_delayTime
      0003F0 74 FF            [12] 1348 	mov	a,#0xff
      0003F2 B5*0E 02         [24] 1349 	cjne	a,_delayTime,00254$
      0003F5 15*0F            [12] 1350 	dec	(_delayTime + 1)
      0003F7                       1351 00254$:
      0003F7                       1352 00119$:
                                   1353 ;	monostable.c:335: delay_ms(50);  // Debouncing delay
      0003F7 90 00 32         [24] 1354 	mov	dptr,#0x0032
      0003FA 12r02r3A         [24] 1355 	lcall	_delay_ms
                                   1356 ;	monostable.c:336: while (BUTTON2 == 0 ) {
      0003FD                       1357 00127$:
      0003FD 20 B1 5E         [24] 1358 	jb	_P3_1,00132$
                                   1359 ;	monostable.c:337: if(longPressTime > 5000-acceleration){
      000400 74 88            [12] 1360 	mov	a,#0x88
      000402 C3               [12] 1361 	clr	c
      000403 95*17            [12] 1362 	subb	a,_acceleration
      000405 FE               [12] 1363 	mov	r6,a
      000406 74 13            [12] 1364 	mov	a,#0x13
      000408 95*18            [12] 1365 	subb	a,(_acceleration + 1)
      00040A FF               [12] 1366 	mov	r7,a
      00040B C3               [12] 1367 	clr	c
      00040C EE               [12] 1368 	mov	a,r6
      00040D 95*15            [12] 1369 	subb	a,_longPressTime
      00040F EF               [12] 1370 	mov	a,r7
      000410 95*16            [12] 1371 	subb	a,(_longPressTime + 1)
      000412 50 37            [24] 1372 	jnc	00126$
                                   1373 ;	monostable.c:338: longPressTime = 0;
      000414 E4               [12] 1374 	clr	a
      000415 F5*15            [12] 1375 	mov	_longPressTime,a
      000417 F5*16            [12] 1376 	mov	(_longPressTime + 1),a
                                   1377 ;	monostable.c:339: if(delayTime < 1){
      000419 C3               [12] 1378 	clr	c
      00041A E5*0E            [12] 1379 	mov	a,_delayTime
      00041C 94 01            [12] 1380 	subb	a,#0x01
      00041E E5*0F            [12] 1381 	mov	a,(_delayTime + 1)
      000420 94 00            [12] 1382 	subb	a,#0x00
      000422 50 08            [24] 1383 	jnc	00121$
                                   1384 ;	monostable.c:340: delayTime = 9999;
      000424 75*0E 0F         [24] 1385 	mov	_delayTime,#0x0f
      000427 75*0F 27         [24] 1386 	mov	(_delayTime + 1),#0x27
      00042A 80 09            [24] 1387 	sjmp	00122$
      00042C                       1388 00121$:
                                   1389 ;	monostable.c:342: delayTime-=1;
      00042C 15*0E            [12] 1390 	dec	_delayTime
      00042E 74 FF            [12] 1391 	mov	a,#0xff
      000430 B5*0E 02         [24] 1392 	cjne	a,_delayTime,00258$
      000433 15*0F            [12] 1393 	dec	(_delayTime + 1)
      000435                       1394 00258$:
      000435                       1395 00122$:
                                   1396 ;	monostable.c:344: if(acceleration < 4500){
      000435 C3               [12] 1397 	clr	c
      000436 E5*17            [12] 1398 	mov	a,_acceleration
      000438 94 94            [12] 1399 	subb	a,#0x94
      00043A E5*18            [12] 1400 	mov	a,(_acceleration + 1)
      00043C 94 11            [12] 1401 	subb	a,#0x11
      00043E 50 0B            [24] 1402 	jnc	00126$
                                   1403 ;	monostable.c:345: acceleration = 30 +acceleration;
      000440 74 1E            [12] 1404 	mov	a,#0x1e
      000442 25*17            [12] 1405 	add	a, _acceleration
      000444 F5*17            [12] 1406 	mov	_acceleration,a
      000446 E4               [12] 1407 	clr	a
      000447 35*18            [12] 1408 	addc	a, (_acceleration + 1)
      000449 F5*18            [12] 1409 	mov	(_acceleration + 1),a
      00044B                       1410 00126$:
                                   1411 ;	monostable.c:348: longPressTime++;
      00044B 05*15            [12] 1412 	inc	_longPressTime
      00044D E4               [12] 1413 	clr	a
      00044E B5*15 AC         [24] 1414 	cjne	a,_longPressTime,00127$
      000451 05*16            [12] 1415 	inc	(_longPressTime + 1)
      000453 80 A8            [24] 1416 	sjmp	00127$
      000455                       1417 00131$:
                                   1418 ;	monostable.c:354: longPressTime = 0;
      000455 E4               [12] 1419 	clr	a
      000456 F5*15            [12] 1420 	mov	_longPressTime,a
      000458 F5*16            [12] 1421 	mov	(_longPressTime + 1),a
                                   1422 ;	monostable.c:355: acceleration =  0;
      00045A F5*17            [12] 1423 	mov	_acceleration,a
      00045C F5*18            [12] 1424 	mov	(_acceleration + 1),a
      00045E                       1425 00132$:
                                   1426 ;	monostable.c:358: buttonStat = BUTTON3;
      00045E A2 82            [12] 1427 	mov	c,_P0_2
      000460 E4               [12] 1428 	clr	a
      000461 33               [12] 1429 	rlc	a
                                   1430 ;	monostable.c:359: if(lastButtonStat != buttonStat){
      000462 F5*0C            [12] 1431 	mov	_buttonStat,a
      000464 B5*0B 02         [24] 1432 	cjne	a,_lastButtonStat,00261$
      000467 80 4D            [24] 1433 	sjmp	00137$
      000469                       1434 00261$:
                                   1435 ;	monostable.c:360: TR0  = 0;
                                   1436 ;	assignBit
      000469 C2 8C            [12] 1437 	clr	_TR0
                                   1438 ;	monostable.c:362: txsecondByte = delayTime ;
      00046B AF*0E            [24] 1439 	mov	r7,_delayTime
                                   1440 ;	monostable.c:363: txfirstByte = delayTime >> 8; 
      00046D AE*0F            [24] 1441 	mov	r6,(_delayTime + 1)
                                   1442 ;	monostable.c:365: if(buttonStat == 1){
      00046F 74 01            [12] 1443 	mov	a,#0x01
      000471 B5*0C 31         [24] 1444 	cjne	a,_buttonStat,00134$
                                   1445 ;	monostable.c:366: I2C_Start(); 
      000474 C0 07            [24] 1446 	push	ar7
      000476 C0 06            [24] 1447 	push	ar6
      000478 12r00r1A         [24] 1448 	lcall	_I2C_Start
                                   1449 ;	monostable.c:367: I2C_DataWrite(0xA0);
      00047B 75 82 A0         [24] 1450 	mov	dpl, #0xa0
      00047E 12r00r36         [24] 1451 	lcall	_I2C_DataWrite
                                   1452 ;	monostable.c:368: I2C_DataWrite(0x00);
      000481 75 82 00         [24] 1453 	mov	dpl, #0x00
      000484 12r00r36         [24] 1454 	lcall	_I2C_DataWrite
                                   1455 ;	monostable.c:369: I2C_DataWrite(0x01);
      000487 75 82 01         [24] 1456 	mov	dpl, #0x01
      00048A 12r00r36         [24] 1457 	lcall	_I2C_DataWrite
      00048D D0 06            [24] 1458 	pop	ar6
                                   1459 ;	monostable.c:370: I2C_DataWrite(txfirstByte);
      00048F 8E 82            [24] 1460 	mov	dpl, r6
      000491 12r00r36         [24] 1461 	lcall	_I2C_DataWrite
      000494 D0 07            [24] 1462 	pop	ar7
                                   1463 ;	monostable.c:371: I2C_DataWrite(txsecondByte);
      000496 8F 82            [24] 1464 	mov	dpl, r7
      000498 12r00r36         [24] 1465 	lcall	_I2C_DataWrite
                                   1466 ;	monostable.c:372: I2C_Stop();
      00049B 12r00r26         [24] 1467 	lcall	_I2C_Stop
                                   1468 ;	monostable.c:373: saving();
      00049E 12r04rBC         [24] 1469 	lcall	_saving
                                   1470 ;	monostable.c:374: TR0 = 1;
                                   1471 ;	assignBit
      0004A1 D2 8C            [12] 1472 	setb	_TR0
      0004A3 80 11            [24] 1473 	sjmp	00137$
      0004A5                       1474 00134$:
                                   1475 ;	monostable.c:377: P2 = displayData[10];
      0004A5 85*0A A0         [24] 1476 	mov	_P2,(_displayData + 0x000a)
                                   1477 ;	monostable.c:378: DISP1=DISP2=DISP3=DISP4 = 1;
                                   1478 ;	assignBit
      0004A8 D2 94            [12] 1479 	setb	_P1_4
                                   1480 ;	assignBit
      0004AA A2 94            [12] 1481 	mov	c,_P1_4
      0004AC 92 93            [24] 1482 	mov	_P1_3,c
                                   1483 ;	assignBit
      0004AE A2 93            [12] 1484 	mov	c,_P1_3
      0004B0 92 92            [24] 1485 	mov	_P1_2,c
                                   1486 ;	assignBit
      0004B2 A2 92            [12] 1487 	mov	c,_P1_2
      0004B4 92 91            [24] 1488 	mov	_P1_1,c
      0004B6                       1489 00137$:
                                   1490 ;	monostable.c:382: lastButtonStat = buttonStat;
      0004B6 85*0C*0B         [24] 1491 	mov	_lastButtonStat,_buttonStat
                                   1492 ;	monostable.c:387: }
      0004B9 02r03r4D         [24] 1493 	ljmp	00139$
                                   1494 ;------------------------------------------------------------
                                   1495 ;Allocation info for local variables in function 'saving'
                                   1496 ;------------------------------------------------------------
                                   1497 ;i                         Allocated to registers r7 
                                   1498 ;j                         Allocated to registers r6 
                                   1499 ;------------------------------------------------------------
                                   1500 ;	monostable.c:389: void saving(void){
                                   1501 ;	-----------------------------------------
                                   1502 ;	 function saving
                                   1503 ;	-----------------------------------------
      0004BC                       1504 _saving:
                                   1505 ;	monostable.c:390: for(int i=0;i<7;i++){
      0004BC 7F 00            [12] 1506 	mov	r7,#0x00
      0004BE                       1507 00112$:
      0004BE BF 07 00         [24] 1508 	cjne	r7,#0x07,00166$
      0004C1                       1509 00166$:
      0004C1 50 64            [24] 1510 	jnc	00114$
                                   1511 ;	monostable.c:391: for(int j=3;j>=0;j--){
      0004C3 7E 03            [12] 1512 	mov	r6,#0x03
      0004C5                       1513 00109$:
      0004C5 EE               [12] 1514 	mov	a,r6
      0004C6 20 E7 5B         [24] 1515 	jb	acc.7,00113$
                                   1516 ;	monostable.c:392: switch(j)
      0004C9 BE 00 02         [24] 1517 	cjne	r6,#0x00,00169$
      0004CC 80 0F            [24] 1518 	sjmp	00101$
      0004CE                       1519 00169$:
      0004CE BE 01 02         [24] 1520 	cjne	r6,#0x01,00170$
      0004D1 80 18            [24] 1521 	sjmp	00102$
      0004D3                       1522 00170$:
      0004D3 BE 02 02         [24] 1523 	cjne	r6,#0x02,00171$
      0004D6 80 21            [24] 1524 	sjmp	00103$
      0004D8                       1525 00171$:
                                   1526 ;	monostable.c:394: case 0:
      0004D8 BE 03 38         [24] 1527 	cjne	r6,#0x03,00105$
      0004DB 80 2A            [24] 1528 	sjmp	00104$
      0004DD                       1529 00101$:
                                   1530 ;	monostable.c:395: DISP1 = 1;
                                   1531 ;	assignBit
      0004DD D2 91            [12] 1532 	setb	_P1_1
                                   1533 ;	monostable.c:396: DISP2 = DISP3 = DISP4 = 0;
                                   1534 ;	assignBit
      0004DF C2 94            [12] 1535 	clr	_P1_4
                                   1536 ;	assignBit
      0004E1 A2 94            [12] 1537 	mov	c,_P1_4
      0004E3 92 93            [24] 1538 	mov	_P1_3,c
                                   1539 ;	assignBit
      0004E5 A2 93            [12] 1540 	mov	c,_P1_3
      0004E7 92 92            [24] 1541 	mov	_P1_2,c
                                   1542 ;	monostable.c:398: break;
                                   1543 ;	monostable.c:399: case 1:
      0004E9 80 28            [24] 1544 	sjmp	00105$
      0004EB                       1545 00102$:
                                   1546 ;	monostable.c:400: DISP2 = 1;
                                   1547 ;	assignBit
      0004EB D2 92            [12] 1548 	setb	_P1_2
                                   1549 ;	monostable.c:401: DISP1 = DISP3 = DISP4 = 0;
                                   1550 ;	assignBit
      0004ED C2 94            [12] 1551 	clr	_P1_4
                                   1552 ;	assignBit
      0004EF A2 94            [12] 1553 	mov	c,_P1_4
      0004F1 92 93            [24] 1554 	mov	_P1_3,c
                                   1555 ;	assignBit
      0004F3 A2 93            [12] 1556 	mov	c,_P1_3
      0004F5 92 91            [24] 1557 	mov	_P1_1,c
                                   1558 ;	monostable.c:403: break;
                                   1559 ;	monostable.c:404: case 2:
      0004F7 80 1A            [24] 1560 	sjmp	00105$
      0004F9                       1561 00103$:
                                   1562 ;	monostable.c:405: DISP3 = 1;
                                   1563 ;	assignBit
      0004F9 D2 93            [12] 1564 	setb	_P1_3
                                   1565 ;	monostable.c:406: DISP1 = DISP2 = DISP4 = 0;
                                   1566 ;	assignBit
      0004FB C2 94            [12] 1567 	clr	_P1_4
                                   1568 ;	assignBit
      0004FD A2 94            [12] 1569 	mov	c,_P1_4
      0004FF 92 92            [24] 1570 	mov	_P1_2,c
                                   1571 ;	assignBit
      000501 A2 92            [12] 1572 	mov	c,_P1_2
      000503 92 91            [24] 1573 	mov	_P1_1,c
                                   1574 ;	monostable.c:408: break;
                                   1575 ;	monostable.c:409: case 3:
      000505 80 0C            [24] 1576 	sjmp	00105$
      000507                       1577 00104$:
                                   1578 ;	monostable.c:410: DISP4 = 1;
                                   1579 ;	assignBit
      000507 D2 94            [12] 1580 	setb	_P1_4
                                   1581 ;	monostable.c:411: DISP1 = DISP2 = DISP3 = 0;
                                   1582 ;	assignBit
      000509 C2 93            [12] 1583 	clr	_P1_3
                                   1584 ;	assignBit
      00050B A2 93            [12] 1585 	mov	c,_P1_3
      00050D 92 92            [24] 1586 	mov	_P1_2,c
                                   1587 ;	assignBit
      00050F A2 92            [12] 1588 	mov	c,_P1_2
      000511 92 91            [24] 1589 	mov	_P1_1,c
                                   1590 ;	monostable.c:414: }
      000513                       1591 00105$:
                                   1592 ;	monostable.c:415: delay_ms(70);
      000513 90 00 46         [24] 1593 	mov	dptr,#0x0046
      000516 C0 07            [24] 1594 	push	ar7
      000518 C0 06            [24] 1595 	push	ar6
      00051A 12r02r3A         [24] 1596 	lcall	_delay_ms
      00051D D0 06            [24] 1597 	pop	ar6
      00051F D0 07            [24] 1598 	pop	ar7
                                   1599 ;	monostable.c:391: for(int j=3;j>=0;j--){
      000521 1E               [12] 1600 	dec	r6
      000522 80 A1            [24] 1601 	sjmp	00109$
      000524                       1602 00113$:
                                   1603 ;	monostable.c:390: for(int i=0;i<7;i++){
      000524 0F               [12] 1604 	inc	r7
      000525 80 97            [24] 1605 	sjmp	00112$
      000527                       1606 00114$:
                                   1607 ;	monostable.c:419: }
      000527 22               [24] 1608 	ret
                                   1609 	.area CSEG    (CODE)
                                   1610 	.area CONST   (CODE)
                                   1611 	.area XINIT   (CODE)
                                   1612 	.area CABS    (ABS,CODE)
